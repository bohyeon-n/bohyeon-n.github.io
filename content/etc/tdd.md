# TDD 

패턴 
- 알려진 문제의 일반적이고 재사용할 수 있는 해결법 
- 프로그래머는 고유한 문제를 풀어야 한다. 
- 고유한 문제는 좀 더 작은 하위 기술 문제를 가진다. 
- 이 작은 기술 문제들 중 많은 일부는 과거 어디에 선가 여러 번 반복되고 해결된 적이 있다. 

pattern always have two parts: the how and the when 

패턴은 해결책, 패턴은 치료약이나 열쇠같은 것 
치료약은 적합한 상처가 잇음, 그게 아닌 곳에 쓰면 해가될 수 있다. 
패턴도 마찬가지다. 어떤 문제가 주어지던, 패턴을 사용하려고 하는게 아니라 이 문제에 적합한 패턴을 알고 있는지, 어떻게 쓰는건지, 해법보다 문제에 더 집중해야 한다. 
어디에나 통하는 만병 통치약은 없다. 
-> 은탄환은 없다. 

더 심각한 문제 <-> 덜 심각한 문제 
완벽하게 문제를 해결하지 못하더라도, 

근육 기억 
반복되는 문제 해결에 비용이 많이 쓰인다면 
연습하고, 연습하고, 연습해서 
생각의 비용을 줄어들도록 뇌에 새겨라. 
반복 작업이 개인의 성장을 이끌기도 한다? 
=> 반복이 완벽함을 만든다? 
워킹데이 10일동안 하루 100개씩 작성해서 테스트 코드와 운영 코드의 결합을 낮춰서 
유연한 설계를 얻을 수 있게 되었고. 이게 근육 기억으로 남아 있음 

## 코드 기능 명세 

모든 프로그램은 입력과 출력을 가짐 
어떤 입력에 대해서 출력이 있었음 좋겠어: 소프트웨어 기능 명세, 굉장히 중요한 영역, 높은 이해를 갖춰야 함 

입력: 사용자 입력, 외부 시스텝 입력, 저장 장치 등, 난수, 시간 ...
출력: 모니터에 출력되는 화면, 소리, 외부 시스템으로 보내는 외부 시스템 출력

어떤 입력을 어떤 출력으로 매핑할 지 기대를 가지고 있음 => 이게 기능 명세 

코드 명세는 어디서 등장을 할까? 도메인! 
소프트웨어는 문제를 푸는 도구 
도메인은 소프트웨어가 풀어야 할 문제가 정의되는 공간 

도메인에 대한 지식은 
비즈니스 전문가 -> 분석가 -> 프로그래머 -> 컴퓨터 

## 프로그래머 
정제된 기능 명세를 아키텍처와 코드로 번역 
- 제품 제작 과정 중 비용이 가장 큰 작업 
- 끊임없이 설계 결정 
- 지식 흐름 과정의 마지막 인간 

## 컴퓨터 
- 코드를 통해 프로그래머로부터 지식을 전달받음 
- 철저히 수동적 
- 융통성 없음 

컴퓨터는 스스로 설계를 결정하지 않기 때문에 프로그래머가 도메인 지식을 컴퓨터에 전달할 때엔 모든 요소들이 명확히 결정될 수 밖에 없음

충분히 명확한 도메인 지식을 확보하지 못한 프로그래머는 지식 흐름 상류에 지식 보강을 요청해야 한다.

하지만 어떤 프로그래머는 스스로 결정을 내림 
=> 도메인 지식 투영에 오차 발생, 무책임함 (ㅜㅜㅜ)

## 단위 테스트 작성 실습 

도메인 지식이 충분하지 않았을 때 어떤 문제가 발생할 수 있을까? 

## 테스트 기법 

- 수동 테스트 
- 테스트 자동화 
- 인수 테스트 
  - 전체 시스템 이상 여부 신뢰도가 높음 
  - 배치된 시스템을 대상으로 검증 
  - 전체 시스템이 문제가 있는지 없는지는 가장 잘 판단해주지만, 문제가 있을 경우 왜 문제가 있는지 프로그래머에게 제공해주지 않음 
  - -> 피드백 품질이 낮음 (현상은 드러나지만 원인은 숨겨짐)

- 단위 테스트 
  - 전체 시스템을 대상으로 하는 것이 아니라, 전체 시스템 중 하위 시스템만 떼어 내서 검증을 함 
  - 테스트를 작성하는 비용도 저렴하고, 관리하는 비용, 실행하는 비용도 낮음 
  - 전체 시스템 이상 여부 신뢰도가 낮음 


## 코드 분해 
모든 프로그래머는 다루는 시스템의 코드를 분해한다.
함수가 될 수 있고, 클래스가 될 수 있고 
도구에 따라서 어떻게든 코드를 분해해서 만들고, 또 분해된 코드를 다시 사용한다. 
언제나 사용하는 코드 분해의 목적, 방법에 대해서 얘기해보자. 
프로그래머는 계속 어떤 문제를 마주하고, 그 문제를 코딩을 사용해서 해결하는 
소프트웨어를 만들어서 문제를 해결하는 일을 계속 반복한다. 

문제의 크기 
프로그래머가 한 번에 다룰 수 있는 문제의 크기는 한계를 가짐 
프로그래머는 더 큰 문제를 자주 마주함 => 시스템의 크기는 점점 커짐 => 큰 문제는 작은 문제로 분해할 수 있음 => 작은 문제의 일부는 반복됨 

모둘화 
인터페이스와 구현 

분해
-  큰 시스템은 더 작은 하위 시스템으로 분해 가능 /교체 가능
조립
- 작은 시스템은 더 큰 사위 시스템으로 조립 가능/ 모듈  
 재 사용/ 라이브러리 

단위 테스트 

어떤 모듈이던지, 인터페이스와 구현으로 나눌 수 있다. 
어떤 기능을 제공하는지, 기능을 사용하려면 어떻게 해얗 ㅏ느지 
구현은 실제로 어떻게 만들어지는지 

인터페이스가 잘 정제되어 있다면, 풀어야 되는 문제, 해법들에 대해서  전체를 다 고려하지 않고, 필요한 부분만 고민해서 사용해서 더 큰 문제를 해결할 수 있다. 

